import { Disclosures } from '../../components/home/faq';
import { Callout, Tab, Tabs } from 'nextra-theme-docs';
import Link from 'next/link';
import dynamic from 'next/dynamic';

export const Demo = dynamic(() =>
  import('../../components/demo').then((mod) => mod.Demo),
);

# Introduction

Million.js est un compilateur d'optimisation extrÃªmement rapide et lÃ©ger qui rend les [composants](https://react.dev) jusqu'Ã  [_**70% plus rapides**_](https://krausest.github.io/js-framework-benchmark/current.html).

**TL;DR:** Imaginez des composants [React](https://react.dev) fonctionnant Ã  la vitesse du JavaScript brut.

## Pourquoi Million.js?

Pour comprendre pourquoi utiliser Million.js, nous devons comprendre comment React met Ã  jour les interfaces. Lorsqu'un Ã©tat ou des propriÃ©tÃ©s d'une application changent, React procÃ¨de Ã  une mise Ã  jour en deux phases : le rendu et la rÃ©conciliation.

Pour illustrer cela, disons que ceci est notre composant `App`:

```jsx
function App() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

Dans ce composant `App`, lorsque je clique sur le bouton, l'Ã©tat de la variable `count` sera mis Ã  jour et la balise `<p>` sera actualisÃ©e pour reflÃ©ter la nouvelle valeur. DÃ©composons cela en deux Ã©tapes.

### Le rendu

La premiÃ¨re Ã©tape est le rendu. Le rendu est le processus de gÃ©nÃ©ration d'un aperÃ§u du composant actuel. Vous pouvez l'imaginer comme simplement "Appeler" la fonction `App` et stocker la sortie dans une variable. Voici Ã  quoi ressemblerait l'aperÃ§u de la fonction `App`:

```jsx
const snapshot = App();

// snapshot =
<div>
  <p>Count: 1</p>
  <button onClick={increment}>Increment</button>
</div>;
```

### La rÃ©conciliation

Afin de mettre Ã  jour l'interface pour reflÃ©ter le nouvel Ã©tat, React doit comparer l'aperÃ§u prÃ©cÃ©dent au nouvel aperÃ§u (_appelÃ© "diffing"_). Le rÃ©conciliateur de React parcourra chaque Ã©lÃ©ment de l'aperÃ§u prÃ©cÃ©dent et le comparera avec le nouvel aperÃ§u. Si l'Ã©lÃ©ment est le mÃªme, il le sautera. Si l'Ã©lÃ©ment est diffÃ©rent, il le mettra Ã  jour.

- La balise `<div>` est la mÃªme, donc elle n'a pas besoin d'Ãªtre mise Ã  jour. âœ…
  - La balise `<p>` est la mÃªme, donc elle n'a pas besoin d'Ãªtre mise Ã  jour. âœ…
    - Le texte Ã  l'intÃ©rieur de la balise `<p>` est diffÃ©rent, donc il doit Ãªtre mis Ã  jour. âš  ï¸
  - La balise `<button>` est la mÃªme, donc elle n'a pas besoin d'Ãªtre mise Ã  jour. âœ…
    - La propriÃ©tÃ© `onClick` est la mÃªme, donc elle n'a pas besoin d'Ãªtre mise Ã  jour. âœ…
    - Le texte Ã  l'intÃ©rieur de la balise `<button>` est le mÃªme, donc il n'a pas besoin d'Ãªtre mis Ã  jour. âœ…

_(total: 6 vÃ©rifications de diffÃ©rences)_

```diff
<div>
-  <p>Count: 0</p>
+  <p>Count: 1</p>
  <button onClick={increment}>Increment</button>
</div>
```

Ã€ partir d'ici, nous pouvons voir que la balise `<p>` doit Ãªtre mise Ã  jour. React mettra ensuite Ã  jour le nÅ“ud DOM `<p>` pour reflÃ©ter la nouvelle valeur.

```jsx
<p>.innerHTML = `Count: ${count}`;
```

### Comment Million.js rend cela plus rapide

React est lent.

Le problÃ¨me avec la rÃ©conciliation de React est qu'elle devient **exponentiellement plus lente** Ã  mesure que vous avez plus d'Ã©lÃ©ments JSX. Avec cette `App` simple, elle n'a besoin de diffÃ©rencier que quelques Ã©lÃ©ments. Dans une application React du monde rÃ©el, vous pouvez facilement avoir des centaines d'Ã©lÃ©ments, ce qui ralentit les mises Ã  jour de l'interface.

Million.js rÃ©sout cela en **sautant complÃ¨tement l'Ã©tape de diffÃ©renciation** et en mettant Ã  jour directement le nÅ“ud DOM.

Voici un exemple conceptuel de fonctionnement du rÃ©conciliateur Million.js :

```jsx
function App() {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);

  // generated by compiler
  if (count !== prevCount) {
    <p>.innerHTML = `Count: ${count}`;
  }

  <button>.onclick = increment;

  // ...
}
```

Remarquez comment lorsque la variable `count` est mis Ã  jour, Million.js mettra Ã  jour directement le nÅ“ud DOM. Million.js transforme la rÃ©conciliation de React de O(n^3) (temps cubique) Ã  O(1) (temps constant).

> Quelle est sa vitesse ? [**â†’ Consultez les benchmarks**](https://krausest.github.io/js-framework-benchmark/current.html)

## Configuration

La CLI de Million.js installera automatiquement le package et configurera votre projet pour vous.

<Tabs items={['npm', 'pnpm', 'yarn', 'bun']} storageKey="selected-manager">
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  npx million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  pnpx million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  yarn add million@latest
  ```
  </Tab>
  {/* prettier-ignore */}
  <Tab>
  ```bash copy
  bunx million@latest
  ```
  </Tab>
</Tabs>

<Callout type="info">
  Million.js est compatible avec React 16 et versions ultÃ©rieures. Si vous
  utilisez une version plus ancienne de React, vous devrez d'abord effectuer une
  mise Ã  niveau.
</Callout>

C'est tout! Votre projet tourne maintenant sur Million.js ğŸ‰

## Million.js vs. React

La dÃ©mo suivante est complÃ¨te et utilise [le rendu basÃ© sur les clÃ©s](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)
pour montrer comment la performance de Million.js se compare Ã  celle de React

<br />

<Demo />

## Des questions ?

Si vous avez des questions ou avez besoin d'assistance, n'hÃ©sitez pas Ã  les poser sur [Discord](https://million.dev/chat) ou Ã  soumettre un problÃ¨me sur [GitHub](https://github.com/aidenybai/million).
